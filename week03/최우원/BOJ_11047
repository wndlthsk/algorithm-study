#include <bits/stdc++.h>
using namespace std;
/* 
1. 매순간 최선을 선택하면 전체에서도 최선인지 확인.
->큰거부터 최대한 많이쓰는게 좋겠구나? 왜냐하면 ** 큰동전은 작은동전의 배수니까**
2. 문제 조건에 "정렬된 숫자 + 최소 or 최대" 나오면 → 그리디 의심!
여기서도 동전 금액들이 주어지고, 최소 개수 구하라고 했음.
금액은 오름차순으로 주어짐.
→ 자연스럽게 큰 금액부터 채우는 게 최적임을 떠올릴 수 있어.
3.가능한 방법이 많고, 그 중에서 "빠른 방법" 필요하면 → 그리디 고려
브루트포스로 전부 다 경우의 수 따지면 너무 오래 걸림.
그리디는 빠르고 간단한 방식으로 최적해를 주려고 하는 것!

한마디 요약
"현재 선택이 미래에도 영향을 미치지 않는 문제다 → 그리디 떠올려!"
*/ 
int n,k;
int a[15];

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int ans = 0;

    cin >> n >> k;
    for( int i = 0; i < n; i++) cin >> a[i];
    for( int j = n-1; j >=0; j--){
        ans += k/a[j];
        k %= a[j];
    }
    cout << ans;

}
