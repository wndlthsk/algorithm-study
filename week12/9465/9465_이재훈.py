T = int(input())
for _ in range(T):
  n = int(input())
  top, bottom = list(map(int, input().split())), list(map(int, input().split()))
  
  dp = [[0] * 3 for _ in range(n + 1)] # 스티커 점수의 최댓값
  dp[1][0] = 0 # j=0, 1번째 줄에서 선택한 스티커가 없는 경우
  dp[1][1] = top[0] # j=1, 1번째 줄에서 위의 스티커를 선택한 경우
  dp[1][2] = bottom[0] # j=2, 1번째 줄에서 아래의 스티커를 선택한 경우
  
  for i in range(2, n + 1):
    dp[i][0] = max(dp[i - 1][1], dp[i - 1][2])
    dp[i][1] = max(dp[i - 1][0], dp[i - 1][2]) + top[i - 1]
    dp[i][2] = max(dp[i - 1][0], dp[i - 1][1]) + bottom[i - 1]
  print(max(dp[n]))

### dp[i-1][0] <= dp[i-1][2]가 항상 성립하지 않습니다.
# dp[i-1][0]은 i-1번째 열에서 스티커를 선택하지 않은 경우의 누적 최대 점수이고,
# dp[i-1][2]는 i-1번째 열에서 아래쪽 스티커를 선택한 경우의 누적 최대 점수입니다.
# 즉, 두 상태는 의미와 전제 조건이 다르기 때문에 단순히 크고 작음으로 비교할 수 없습니다.

### 🔍 각 상태가 의미하는 것 다시 정리
# dp[i-1][0]: i-1열에서는 아무 것도 선택하지 않음.
# 따라서 i-1열의 상/하 스티커와 무관하게 i열의 위/아래를 모두 선택할 수 있는 완전히 열려 있는 상태.

# dp[i-1][2]: i-1열에서 아래 스티커를 선택함.
# 따라서 i열에서는 아래 스티커를 선택할 수 없고, 위쪽 스티커만 선택 가능한 상태.
# => dp[i-1][2]는 dp[i]에서 선택의 자유도가 제한되기 때문에, dp[i-1][0]보다 작을 수 있습니다.