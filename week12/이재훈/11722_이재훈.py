N = int(input())
Ai = list(map(int, input().split()))

dp = [0] * (N + 1) # 가장 긴 감소하는 부분 수열의 길이

for i in range(1, N + 1):
  dp[i] = 1
  for j in range(1, i + 1):
    if Ai[j - 1] > Ai[i - 1]: # 감소 수열을 연결할 수 있는 경우
      dp[i] = max(dp[i], dp[j] + 1) # 여러 j 중에서 누가 가장 긴지 모르기 때문에 max로 비교
print(max(dp))

# if문에 해당되면, 항상 dp[i] = dp[j] + 1 아닌가?
# NO. 감소 수열이긴 하지만 여러 후보가 존재함.

# Ai = [30, 20, 15, 10]
# i = 4 (Ai[3] = 10)
#
# 가능한 j들:
# j=1 (Ai[0]=30) → dp[1]+1 → 2
# j=2 (Ai[1]=20) → dp[2]+1 → 3
# j=3 (Ai[2]=15) → dp[3]+1 → 4  ← 가장 긴 경우!
# 
# 따라서 dp[4] = max( dp[4], dp[j]+1 )


# max( dp[4], )
# 여러 j를 반복하면서 갱신(현재까지 가장 긴 길이)된 dp[i]임.

# dp[4] = max( 기존 dp[4], 새로운 후보(dp[j] + 1) )
# 기존 dp[4] → 지금까지 반복한 j들에서 구한 최선값
# 새로운 dp[j]+1 → 현재 j를 선택해 Ai[3]을 넣었을 때 길이
# 둘 중 더 큰 걸 dp[4]에 넣어서 계속 "최대 길이" 유지