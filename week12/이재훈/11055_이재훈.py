N = int(input())
Ai = list(map(int, input().split()))

dp = [0] * (N + 1) # 수열 A의 합이 가장 큰 증가하는 부분 수열의 합
# dp[i]: i번째 원소를 마지막으로 하는 증가하는 부분 수열의 합의 최댓값

for i in range(1, N + 1):
  dp[i] = Ai[i - 1] # 초기화 (자기 자신만 쓴 경우)
  for j in range(1, i + 1): # j는 i보다 "앞쪽 수들"
    if Ai[i - 1] > Ai[j - 1]: # 앞쪽 수보다 클 때만 "붙일 수 있음"
      dp[i] = max(dp[i], dp[j] + Ai[i - 1]) # 기존 누적 유지 or 앞에서 이어붙여서 더 좋은 경우 선택
print(max(dp))

# 하나만 선택한 경우 (마지막 수 선택한 모든 경우)가 우선되어야,
# 마지막으로 오는 수 앞에 덧붙일 수 있는 수 판단 가능.

# "혼자만 쓴 경우"도 정답 후보이고,
# 그걸 기준으로 "앞에서 이어붙여서 더 좋은 경우가 있으면 갱신"하는 구조