#include <bits/stdc++.h>
using namespace std;
//다익스트라 알고리즘은 매 단계마다 도달할 수 있는 정점 중에서 시작점으로부터의 거리가 가장 가까운 정점을 구해서 그 거리를 확정하는 방식으로 동작합니다. 

// A*algorith 대신 다익스트라를 사용하는 이유
/*  A* 알고리즘은 대표적으로 네비게이션에서의 

길찾기처럼 100% 정확한 최단거리를 내지 않아도 되고, 또 정점의 개수가 너무 많아 현실적으로 다익스트라 알고리즘을 사용하기
힘들 경우에 유용하게 사용할 수 있는 근사 알고리즘입니다. 그러나 저희가 문제를 푸는 상황에서는 대부분의
경우 정확한 답을 필요로 하지 근사치를 원하는게 아닙니다. 그래서 A* 알고리즘을 알 필요가 없고 그냥 다익스트라 알고리즘만 익히면 됩니다. */

//시간 복잡도도
/* 1번 정점과 연결된 정점의 목록을 다 살피고, 2번 정점과 연결된 정점의 목록을 다 살피고,
 3번 정점과 연결된 목록을 다 살피면 구할 수 있습니다. 그런데 이렇게 구현을 하면 대략적으로 매 단계마다 
 간선을 다 훑어야 한다는 의미입니다. 그래서 O(VE)가 돼요. 반면 새 정점을 추가할 때 마다 미리 테이블에 거리를 계산해두고 
 거기서 최솟값을 찾는 방식으로 하면 O(V2 + E)이고 일반적으로 E가 V보다 크니 O(VE)보다 O(V2+E)가 효율적입니다 */

vector<pair<int,int>> adj[20005];
const int INF = 0x3f3f3f3f;
bool fix[20005];
int d[20005];
int v = 10;
// 아래 함수는 1950년도 다익스트라 알고리즘의 원리를 보여주는 코드 시간복잡도 O(v^2+E)라서 정점이 20000개 되면 못품품
void dijkstra_native(int st){
        fill(d,d+v+1,INF);  // 최단거리 테이블 초기화
        d[st] =0;
        while(true){
            int idx = -1;
            for(int i = 1; i <= v; i++){
                if(fix[i]) continue;
                if(idx == -1) idx = i;
                else if(d[i] < d[idx]) idx = i;
            }
            if(idx == -1 || d[idx] == INF) // 더 이상 선택할 방법이 없으면
                break;
            fix[idx] =1; //정점 idx고정정
            for(auto nxt : adj[idx])
                d[nxt.Y] = min(d[nxt.Y], d[idx] + nxt.X);
        }
    }


int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

    /* 
    1.배열 구현하기
    2.정점 + 간선 구현하기
    3.특정 정점에서 가장 가까운 정점 찾고 배열에 이를 최신화 하기.
    4.
      */

}
